---
title: "Java & Clocks"
permalink: /posts/java-e-clocks
published: true
description: Sabe a diferen√ßa entre System.currentTimeMillis() e System.nanoTime()?
tags: [Java]
cover_image: /assets/images/pexels-miguel-a-padrinan-745365.jpg
publish_date: 2021-10-07 08:45:00 +0300
---

Lendo o livro "Designing Data-Intensive Applications" aprendi algo muito util em Java. Sabia que System.currentTimeMillis() e System.nanoTime() s√£o duas funcionalidades completamente diferente?

Para entender isso tem que se entender o conceito de Monotonic e Time-of-Day Clocks.

Clock √© um sistema independente dentro de qualquer m√°quina que alimenta um contador independente da CPU. Tem um tick que incrementa esse contador e  esse contador √© usado para calcular a data.

Data √© o n√∫mero segundos/milissegundos desde do Epoch, que √© 1¬∫ de janeiro de 1970 00:00:00. 

D√° uma lida na documenta√ß√£o do GNU sobre a procedimento [clock_gettime](https://www.gnu.org/software/libc/manual/html_node/Getting-the-Time.html). Observa os par√¢metros, v√™ que s√£o dois clocks diferentes?

No `CLOCK_REALTIME`, vai retornar um contador que √© sempre atualizado pelo Sistema Operacional usando o servidor [NTP](https://ntp.br).

No `CLOCK_MONOTONIC` temos um contador monotonico, isso signitica que n√£o vai ser atualizado pelo NTP.

# Quais as implica√ß√µes disso? 

Sempre que voc√™ for usar o clock para pegar a data atual, use `CLOCK_REALTIME`. Ele estar√° mais pr√≥ximo da verdade (observer que ele tem um erro).

Sempre que voc√™ for calcular tempos de execu√ß√£o, use `CLOCK_MONOTONIC`. Ele dar√° o real tempo de execu√ß√£o.

Em Java o `System.currentTimeMillis()` usa o `CLOCK_REALTIME` e o `System.nanoTime()` usa o `CLOCK_MONOTONIC`. 

Isso porque o real time n√£o tem tanta resolu√ß√£o, tem que se descontar a lat√™ncia da rede entre o seu computador e o servidor NTP.

Imagina o caso abaixo:

```java
long startTime = System.currentTimeMillis();
// ... c√≥digo ...
long elapsedMillis = System.currentTimeMillis() - startTime;
```

Durante a execu√ß√£o o SO pode ter atualizado o clock e o elapsedMillis pode at√© ser negativo.

J√° o c√≥digo abaixo, temos a certeza que n√£o foi atualizado.

```java
long startTime = System.nanoTime();
// ... c√≥digo ...
long elapsedNanos = System.nanoTime() - startTime;
```

E se eu quiser o tempo real universal? Acho que Einstein se entristece com essa pergunta, mas blz! 

O Google tem uma API chamada [TrueTime](https://research.google/pubs/pub45855/), que vai retornar a data baseada em v√°rios servidores NTP e um intervalo de erro. Toda medida tem erro no mundo... Aceite!
  
Mas o TrueTime s√≥ √© √∫til em caso de resolu√ß√£o de conflitos de concorr√™ncia complexos.

Ainda n√£o achei uma API do TrueTime para Java (s√≥ para Android). Tamb√©m nunca precisei. üòâ

<blockquote class="twitter-tweet"><p lang="pt" dir="ltr">Lendo o livro &quot;Designing Data-Intensive Applications&quot; aprendi algo muito util em <a href="https://twitter.com/java?ref_src=twsrc%5Etfw">@Java</a>. <br><br>Sabia que System.currentTimeMillis() e System.nanoTime() s√£o duas funcionalidades completamente diferente?</p>&mdash; dev-roadmap (@dev_roadmap) <a href="https://twitter.com/dev_roadmap/status/1446064000165416964?ref_src=twsrc%5Etfw">October 7, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>